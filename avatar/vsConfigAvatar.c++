//------------------------------------------------------------------------
//
//    VIRTUAL ENVIRONMENT SOFTWARE SANDBOX (VESS)
//
//    Copyright (c) 2001, University of Central Florida
//
//       See the file LICENSE for license information
//
//    E-mail:  vess@ist.ucf.edu
//    WWW:     http://vess.ist.ucf.edu/
//
//------------------------------------------------------------------------
//
//    VESS Module:  vsConfigAvatar.c++
//
//    Description:  Avatar subclass that operates completely off of the
//                  data within a configuration file; no subclassing of
//                  this class should be required.
//
//    Author(s):    Bryan Kline
//
//------------------------------------------------------------------------

#include "vsConfigAvatar.h++"

// ------------------------------------------------------------------------
// Constructor
// ------------------------------------------------------------------------
vsConfigAvatar::vsConfigAvatar() : vsAvatar(), updateList(10, 10)
{
    // Initialize the list of updatable objects to empty
    updateListSize = 0;
}

// ------------------------------------------------------------------------
// Constructor
// Passes the specified scene graph through to the parent class'
// constructor
// ------------------------------------------------------------------------
vsConfigAvatar::vsConfigAvatar(vsComponent *scene) : vsAvatar(scene),
    updateList(10, 10)
{
    // Initialize the list of updatable objects to empty
    updateListSize = 0;
}

// ------------------------------------------------------------------------
// Destructor
// Destroys the contents of the avatar's updatable object list
// ------------------------------------------------------------------------
vsConfigAvatar::~vsConfigAvatar()
{
    int loop;
    
    // Delete each object in the update list
    for (loop = 0; loop < updateListSize; loop++)
        if (updateList[loop])
            delete ((vsUpdatable *)(updateList[loop]));
}

// ------------------------------------------------------------------------
// Updates this avatar by calling update on every object in its list
// ------------------------------------------------------------------------
void vsConfigAvatar::update()
{
    int loop;
    
    // Send an update call to each object in the update list
    for (loop = 0; loop < updateListSize; loop++)
        if (updateList[loop])
            ((vsUpdatable *)(updateList[loop]))->update();
}

// ------------------------------------------------------------------------
// Sets this avatar up by building the list of objects owned by the avatar
// that need to be updated each frame. This list is mostly the list of
// objects created by the configuration file reader, but with
// non-updatable objects removed, and with vsKinematics objects moved to
// the end of the list. (vsKinematics objects must be updated last because
// they depend on data generated by the other objects' update functions,
// but they're not specified last in the config file; motion models that
// use the kinematics objects must appear later in the file.)
// ------------------------------------------------------------------------
void vsConfigAvatar::setup()
{
    vsGrowableArray kinArray(10, 10);
    int kinArraySize = 0;
    int loop;

    // If we're not currently initializing the avatar, abort
    if (!objectArray)
        return;

    // For each object, determine what it is from the type string.
    // vsKinematics objects are stored in a temporary array so they can be
    // added onto the update list later. A scene graph (specified by the
    // "geometry" type) is stored in the parent class' geometryRoot variable
    // for later use. All other types that start with "vs" are assumed to
    // be subclasses of vsUpdatable and are added directly to the update
    // list. Everything else is ignored.
    for (loop = 0; loop < objectCount; loop++)
    {
        if (!strcmp((char *)(objTypeArray->getData(loop)), "vsKinematics"))
            kinArray[kinArraySize++] = objectArray->getData(loop);
        else if (!strcmp((char *)(objTypeArray->getData(loop)), "geometry"))
            geometryRoot = (vsComponent *)(objectArray->getData(loop));
        else if (!strncmp((char *)(objTypeArray->getData(loop)), "vs", 2))
            updateList[updateListSize++] = objectArray->getData(loop);
    }
    
    // Add the stored vsKinematics objects to the end of the update list
    for (loop = 0; loop < kinArraySize; loop++)
        updateList[updateListSize++] = kinArray[loop];
}
